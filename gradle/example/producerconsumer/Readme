在多线程开发中，最经典的一个模型就是生产者消费者模型，他们有一个缓冲区，缓冲区有最大限制，当缓冲区满

的时候，生产者是不能将产品放入到缓冲区里面的，当然，当缓冲区是空的时候，消费者也不能从中拿出来产品，这就

涉及到了在多线程中的条件判断，java为了实现这些功能，提供了wait和notify方法，他们可以在线程不满足要求的时候

让线程让出来资源等待，当有资源的时候再notify他们让他们继续工作，下面我们用实际的代码来展示如何使用wait和

notify来实现生产者消费者这个经典的模型。


需要注意的概念是：  
   1.调用obj的wait()， notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj) {……} 代码段内。  
   2.调用obj.wait()后，线程A就释放了obj的锁，否则线程B无法获得obj锁，也就无法在synchronized(obj) {……} 代码段内唤醒A.  
   3.当obj.wait()方法返回后，线程A需要再次获得obj锁，才能继续执行。  
   4.如果A1，A2，A3都在obj.wait()，则B调用obj.notify()只能唤醒A1，A2，A3中的一个（具体哪一个由JVM决定）。  
   5.obj.notifyAll()则能全部唤醒A1，A2，A3，但是要继续执行obj.wait()的下一条语句，必须获得obj锁，因此，A1，A2，A3只有一个有机会获得锁继续执行，例如A1，其余的需要等待A1释放obj锁之后才能继续执行。
   6.当B调用obj.notify/notifyAll的时候，B正持有obj锁，因此，A1，A2，A3虽被唤醒，但是仍无法获得obj锁。直到B退出synchronized块，释放obj锁后，A1，A2，A3中的一个才有机会获得锁继续执行。
